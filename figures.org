#+title: Figures
#+property: header-args :session figs

Python code for generation of figures used in report

#+begin_src jupyter-python
import os

import numpy as np
from osgeo import gdal

import matplotlib as mpl
import matplotlib.pyplot as plt

import torch
import torch.nn as nn
import torchvision.transforms as transforms
#+end_src

#+RESULTS:


#+begin_src jupyter-python
def normalise(arr):
    normalized = (arr - arr.min()) / (arr.max() - arr.min())

    normalized = 2*normalized - 1

    return normalized

def partial_norm(arr):
    normalized = (arr - arr.min()) / (arr.max() - arr.min())

    normalized = normalized - 1

    return normalized

#+end_src

#+RESULTS:

#+begin_src jupyter-python
def tile(dataset, kernel_size):

    dem = gdal.Open(dataset)

    crs = dem.GetProjection()
    geo_transform = dem.GetGeoTransform()

    image = dem.ReadAsArray()

    img_height, img_width = image.shape
    tile_height, tile_width = kernel_size

    # If cant divide perfectly
    if (img_height % tile_height != 0 or img_width % tile_width != 0):
        new_height = img_height - (img_height % tile_height)
        new_width = img_width - (img_width % tile_width)

        image = image[:new_height, :new_width]

    tiles_high = img_height // tile_height
    tiles_wide = img_width // tile_width

    tiled_array = image.reshape(tiles_high,
                                tile_height,
                                tiles_wide,
                                tile_width )

    tiled_array = tiled_array.swapaxes(1, 2)

    tiled_array = tiled_array.reshape(tiles_high * tiles_wide, tile_height, tile_width)

    # GC should get this, but just to be safe
    dem = None

    min_max = []
    for arr in tiled_array:
        min_max.append((arr.min(), arr.max()))

    vectorized_normalise = np.vectorize(normalise, signature='(n,m)->(n,m)')
    vectorized_partial_norm = np.vectorize(partial_norm, signature='(n,m)->(n,m)')

    tiled_array = vectorized_normalise(tiled_array)

    # Slope
    cellsize = geo_transform[1]
    px, py = np.gradient(tiled_array, cellsize, axis=(1,2))
    slope = np.arctan(np.sqrt(px ** 2 + py ** 2))
    slope = vectorized_partial_norm(slope)

    all = np.stack((tiled_array, slope), axis=3)

    # tiled_array = np.expand_dims(tiled_array, axis=3)
    all = np.transpose(all, (0, 3, 1, 2))

    # H,W,C to C,H,W
    return torch.from_numpy(all), min_max, crs, geo_transform

#+end_src

#+RESULTS:

* Fig 1 - Lunar DEM

#+begin_src jupyter-python
dem = '/home/struan/Development/Inpaint/Final Network/data/NAC_DTM_APOLLO17.TIF'

dem = gdal.Open(dem)
arr = dem.ReadAsArray()

threshold = -10000
arr[arr < threshold] = np.nan

#+end_src

#+RESULTS:

#+begin_src jupyter-python
plt.imshow(arr, cmap='terrain')
plt.axis('off')
plt.colorbar()
plt.savefig('images/apollo_17.png', bbox_inches='tight')
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/6fabe65aedde159c6fa9b4c9d26d0dc7bd710205.png]]


* Fig 2 - Slope

#+begin_src jupyter-python
dem = '/home/struan/Development/Inpaint/Final Network/datac/NAC_DTM_APOLLO17.TIF'

tiled = tile(dem, (256,256))
#+end_src

#+RESULTS:

#+begin_src jupyter-python
tile_n = 0
tile = tiled[0][tile_n]

tile = torch.transpose(tile, (1, 2, 0))
plt.imshow(tile[0])
#+end_src

#+RESULTS:
:RESULTS:
# [goto error]
#+begin_example
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
Cell In[35], line 4
      1 tile_n = 0
      2 tile = tiled[0][tile_n]
----> 4 tile = torch.transpose(tile, (1, 2, 0))
      5 plt.imshow(tile[0])

TypeError: transpose() received an invalid combination of arguments - got (Tensor, tuple), but expected one of:
 ,* (Tensor input, int dim0, int dim1)
 ,* (Tensor input, name dim0, name dim1)
#+end_example
:END:
