#+title: Figures
#+property: header-args :session figs

Python code for generation of figures used in report

#+begin_src jupyter-python
import os

import numpy as np
from osgeo import gdal

import matplotlib as mpl
import matplotlib.pyplot as plt

import torch
import torch.nn as nn
import torchvision.transforms as transforms
#+end_src

#+RESULTS:


#+begin_src jupyter-python
def normalise(arr):
    normalized = (arr - arr.min()) / (arr.max() - arr.min())

    normalized = 2*normalized - 1

    return normalized

def partial_norm(arr):
    normalized = (arr - arr.min()) / (arr.max() - arr.min())

    normalized = normalized - 1

    return normalized

#+end_src

#+RESULTS:

#+begin_src jupyter-python
def tile(dataset, kernel_size):

    dem = gdal.Open(dataset)

    crs = dem.GetProjection()
    geo_transform = dem.GetGeoTransform()

    image = dem.ReadAsArray()

    img_height, img_width = image.shape
    tile_height, tile_width = kernel_size

    # If cant divide perfectly
    if (img_height % tile_height != 0 or img_width % tile_width != 0):
        new_height = img_height - (img_height % tile_height)
        new_width = img_width - (img_width % tile_width)

        image = image[:new_height, :new_width]

    tiles_high = img_height // tile_height
    tiles_wide = img_width // tile_width

    tiled_array = image.reshape(tiles_high,
                                tile_height,
                                tiles_wide,
                                tile_width )

    tiled_array = tiled_array.swapaxes(1, 2)

    tiled_array = tiled_array.reshape(tiles_high * tiles_wide, tile_height, tile_width)

    # GC should get this, but just to be safe
    dem = None

    min_max = []
    for arr in tiled_array:
        min_max.append((arr.min(), arr.max()))

    vectorized_normalise = np.vectorize(normalise, signature='(n,m)->(n,m)')
    vectorized_partial_norm = np.vectorize(partial_norm, signature='(n,m)->(n,m)')

    tiled_array = vectorized_normalise(tiled_array)

    # Slope
    cellsize = geo_transform[1]
    px, py = np.gradient(tiled_array, cellsize, axis=(1,2))
    slope = np.arctan(np.sqrt(px ** 2 + py ** 2))
    slope = vectorized_partial_norm(slope)

    all = np.stack((tiled_array, slope), axis=3)

    # tiled_array = np.expand_dims(tiled_array, axis=3)
    all = np.transpose(all, (0, 3, 1, 2))

    # H,W,C to C,H,W
    return torch.from_numpy(all), min_max, crs, geo_transform

#+end_src

#+RESULTS:

* Fig 1 - Lunar DEM

#+begin_src jupyter-python
dem = '/home/struan/Development/Inpaint/Final Network/data/NAC_DTM_APOLLO17.TIF'

dem = gdal.Open(dem)
arr = dem.ReadAsArray()

threshold = -10000
arr[arr < threshold] = np.nan

#+end_src

#+RESULTS:

#+begin_src jupyter-python
plt.imshow(arr, cmap='terrain')
plt.axis('off')
plt.colorbar()
plt.savefig('images/apollo_17.png', bbox_inches='tight')
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/6fabe65aedde159c6fa9b4c9d26d0dc7bd710205.png]]


* Fig 2 - Slope

#+begin_src jupyter-python
dem = '/home/struan/Development/Inpaint/Final Network/datac/NAC_DTM_APOLLO17.TIF'

tiled = tile(dem, (256,256))
#+end_src

#+RESULTS:

#+begin_src jupyter-python
tile_n = 7
t = tiled[0][tile_n]

t = t.cpu().detach().numpy()

t = np.transpose(t, (1, 2, 0))


plt.figure(figsize=(8,10))
plt.subplot(1,2,1)
plt.imshow(t[:,:,0], cmap='terrain')
plt.title("DEM")
plt.axis('off')
plt.subplot(1,2,2)
plt.imshow(t[:,:,1], cmap='viridis')
plt.title("Slope")
plt.axis('off')
plt.savefig('images/dem_and_slope.png', bbox_inches='tight')
plt.show()
# plt.colorbar()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/39ce4a346485fc886283636e3c62482d1a9460a8.png]]
